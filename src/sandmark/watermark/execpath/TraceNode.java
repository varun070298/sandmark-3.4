package sandmark.watermark.execpath;

/** This class contains the trace info at the start of one particular basic block.
 *	 Trace info includes static/instance/local variable values, offset of the starting
 *	 instruction of the BB, number of successors of the BB, class/method/method signature 
 *  containing the BB, and the bits (if any) generated by running this basic block, and 
 *  also whether these bits appear in the final bit sequence string.
*/
public class TraceNode{
   public static final int TYPE_IF = 0;
   public static final int TYPE_SWITCH = 1;
   public static final int TYPE_OTHER = 2;
   
   private VarValue[] varvalues;
   private int offset;
   private int numSuccessors;
   private String threadName;
   private String className;
   private String methodName;
   private String methodSignature;
   private String bits;
   private int nodeType;
   
   protected TraceNode(String line, String bit){
       java.util.StringTokenizer st = new java.util.StringTokenizer(line,":");
      
      String blocktype = st.nextToken();
      nodeType = TYPE_OTHER;
      if (blocktype.equals("{if}"))
         nodeType = TYPE_IF;
      else if (blocktype.equals("{switch}"))
         nodeType = TYPE_SWITCH;
      else
         nodeType = TYPE_OTHER;
      
      threadName = st.nextToken().intern();
      className = st.nextToken().intern();
      String methodNameAndSig = st.nextToken();
      int sigStart = methodNameAndSig.indexOf("(");
      methodName = methodNameAndSig.substring(0,sigStart).intern();
      methodSignature = methodNameAndSig.substring(sigStart).intern();
      offset = Integer.parseInt(st.nextToken());
      numSuccessors = Integer.parseInt(st.nextToken());
      bits = bit;

      java.util.Vector list = new java.util.Vector(10);
      while(st.hasMoreTokens()){
         list.add(new VarValue(st.nextToken()));
      }
		
      varvalues = (VarValue [])list.toArray(new VarValue[0]);
   }


   /** Returns an int indicating the type of bb this is 
       (one of TYPE_IF, TYPE_SWITCH, or TYPE_OTHER).
   */
   public int getNodeType(){
      return nodeType;
   }

   /** Returns the piece of the bit string generated at this
    *  point in the trace (may be "").
    */
   public String getBits(){
      return bits;
   }

   /** Returns the offset of the first instruction
    *  in this BB.
    */
   public int getOffset(){
      return offset;
   }

   /** Returns the number of successors of this BB.
    */
   public int getNumSuccessors(){
      return numSuccessors;
   }
	
   /** Returns the name of the current thread in this trace.
    */
   public String getThreadName(){
      return threadName;
   }

   /** Returns the name of the class whose method contains this trace point.
    */
   public String getClassName(){
      return className;
   }

   /** Returns the method in which this trace point exists.
    */
   public String getMethodName(){
      return methodName;
   }

   /** The signature of getMethodName()
    */
   public String getMethodSignature(){
      return methodSignature;
   }
	
   /** Returns a list of static/instance/local variables along with their
    *	 values at this trace point.
    */
   public VarValue[] getVarValues(){
      return varvalues;
   }

   public String toString(){
      String result = threadName+","+className+":"+methodName+
         methodSignature+" ["+offset+"] = "+bits;
      for (int i=0;i<varvalues.length;i++){
         result += "\n" + varvalues[i];
      }
      return result;
   }
}
