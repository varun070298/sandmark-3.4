package sandmark.diff.methoddiff;

/** A method diff algorithm that considers the positional relationship
 *  between variable uses.
 *  @author Zach Heidepriem
 */

public class BakerAlgorithm extends sandmark.diff.methoddiff.MethodDiffAlgorithm {
    private boolean DEBUG = false;  
   
    /** Construct a BakerAlgorithm
     *  @param a the first Application
     *  @param b the second Application
     *  @param o the set of DiffOptions to use when diffing
     */
    public BakerAlgorithm(sandmark.program.Application a,
      sandmark.program.Application b,
      sandmark.diff.DiffOptions o){
	super(a,b, o);
    }
    /** @return the name of this algorithm
     */ 
    public String getName(){ return "Baker-Manber algorithm"; }
    /** @return a short description of this algorithm
     */   
    public String getDescription(){ 
        return "Compare methods while considering the positional relationship " +
            "between variable uses"; 
    }      
 	    
    /** @param r The Result object to color
     *  @return The Coloring for r using this algorithm
     */
    public sandmark.diff.Coloring[] color(sandmark.diff.Result r){
	sandmark.diff.Coloring[] result = new sandmark.diff.Coloring[2];	
        sandmark.program.Method m1 = (sandmark.program.Method)
            r.getObject1();
        sandmark.program.Method m2 = (sandmark.program.Method)
            r.getObject2();        
	
        int[] array1 = computeOffsets(m1);
	int[] array2 = computeOffsets(m2);   
       
	org.apache.bcel.generic.InstructionHandle[] orig1 =
	    m1.getInstructionList().getInstructionHandles();
	org.apache.bcel.generic.InstructionHandle[] orig2 =
	    m2.getInstructionList().getInstructionHandles();
    
	java.util.Vector[] data = sandmark.diff.LCS.getSubsequence(array1, array2);
	result[0] = new sandmark.diff.Coloring(orig1.length, 
                                               m1.getClassName() + 
                                               "." +
                                               m1.getName());
	for(int i = 0; i < orig1.length; i++){
	    if(data[0].contains(new Integer(i)))
		result[0].add(i, orig1[i].toString(), 1);
	    else result[0].add(i,orig1[i].toString());
	}
	result[1] = new sandmark.diff.Coloring(orig2.length, 
                                               m2.getClassName() + 
                                               "." +
                                               m2.getName());
	for(int i = 0; i < orig2.length; i++){
	    if(data[1].contains(new Integer(i)))
		result[1].add(i, orig2[i].toString(), 1);
	    else result[1].add(i, orig2[i].toString());
	}
	return result;
    }    
 
    /** Diff two given objects using this algorithm
     *  @param m1 the first method
     *  @param m2 the second method
     *  @return a Result object generated by this algorithm
     */
    public sandmark.diff.Result diffMethods(sandmark.program.Method m1, 
                                            sandmark.program.Method m2){
        
        if(m1.getInstructionList() == null || m2.getInstructionList() == null){
            if(options.getFilter() == 0)
                return new sandmark.diff.Result(m1, m2, 0); 
            else 
                return null;
        }         
        int[] array1 = computeOffsets(m1);
        int[] array2 = computeOffsets(m2);
        
        double lcs = (double)sandmark.diff.LCS.getLength(array1, array2);		
        double similarity = lcs / (double)Math.max(array1.length, array2.length);
        if(sandmark.diff.DiffUtil.sameNames(m1,m2) || similarity >= options.getFilter())
            return new sandmark.diff.Result(m1, m2, similarity);                
        return null;
    }     

   private int[] computeOffsets(sandmark.program.Method mg){
     
	java.util.Hashtable cpTable = new java.util.Hashtable();
	java.util.Hashtable lvTable = new java.util.Hashtable();
      
        java.util.Vector v = new java.util.Vector();

	org.apache.bcel.generic.Instruction[] instrs = 
	    mg.getInstructionList().getInstructions();       
	
	sandmark.diff.InstructionWrapper[] wrappers = 
            new sandmark.diff.InstructionWrapper[instrs.length];
	for(int i = 0; i < instrs.length; i++)
            wrappers[i] = new sandmark.diff.InstructionWrapper(instrs[i]);        
        
	for(int i = 0; i < wrappers.length; i++){	   	    	    
            int op = wrappers[i].getOpcode(), arg = 0;            
            if(wrappers[i].getArgType() == sandmark.diff.InstructionWrapper.LV_INDEX){
		int newIndex = 0;
		Integer oldIndex = new Integer(-1);
		try{
		    oldIndex = new Integer(wrappers[i].getLVIndex());
		}catch(Exception e){ System.out.println("No local variable index."); }
		if(lvTable.containsKey(oldIndex)){
		    int tmp = ((Integer)lvTable.get(oldIndex)).intValue();
		    newIndex = i - tmp;
		    lvTable.put(oldIndex, new Integer(i)); //the line number of last use
		}
		else
		    lvTable.put(oldIndex, new Integer(i));		
          
                arg = newIndex;		
	    }
	    else if(wrappers[i].getArgType() == sandmark.diff.InstructionWrapper.CP_INDEX){
		int newIndex = 0;
		Integer oldIndex = new Integer(-1);
		try{
		    oldIndex = new Integer(wrappers[i].getCPIndex());
		}catch(Exception e){ System.out.println("No constant pool index."); }
		if(cpTable.containsKey(oldIndex)){
		    int tmp = ((Integer)cpTable.get(oldIndex)).intValue();
		    newIndex = i - tmp;
		    cpTable.put(oldIndex, new Integer(i)); //the line number of last use
		}	   
		else
		    cpTable.put(oldIndex, new Integer(i));
	
                arg = newIndex;
	    }	    
            else if(wrappers[i].getArgType() == sandmark.diff.InstructionWrapper.OFFSET){
                try{
                    arg = wrappers[i].getOffset();                
                }catch(Exception e){ System.out.println("No offset."); }
            }
            else if(wrappers[i].getArgType() == sandmark.diff.InstructionWrapper.CONST){
                try{
                    arg = wrappers[i].getConstArg().intValue();
                }catch(Exception e){ System.out.println("No const."); }
            }
            v.add(new Integer(sandmark.diff.DiffUtil.pack(op,arg)));
        }                                          
        int[] a = new int[v.size()];
        for(int i = 0; i < v.size(); i++)
            a[i] = ((Integer)v.get(i)).intValue();
	return a;
    }
}

