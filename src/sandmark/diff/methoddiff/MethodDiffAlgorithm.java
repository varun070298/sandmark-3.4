package sandmark.diff.methoddiff;

/** A MethodDiffAlgorithm will perform a comparison of any two methods,
 *  reporting similarities and/or differences.
 *  This abstract class implements the run method to extract the elements
 *  from the application objects. We also implement the getCurrent() and
 *  getTaskLength methods in order to keep track of the progress of run()
 *  @author Zach Heidepriem
 */

public abstract class MethodDiffAlgorithm extends sandmark.diff.DiffAlgorithm {   

    protected int current, taskLength;
    protected boolean stop;

   /** Construct a MethodDiffAlgorithm
     *  @param a the first Application
     *  @param b the second Application
     *  @param o the set of DiffOptions to use when diffing
     */
    public MethodDiffAlgorithm(sandmark.program.Application a,
                               sandmark.program.Application b,
                               sandmark.diff.DiffOptions o){
       super(a, b, o);       
       current = 0; 
       taskLength = -1;       
    }
    
  
    /**The run method creates and fills the results for this algorithm.
     * After calling run(), call getResults() to retrieve the results.
     * Compares methods using this object's diffMethods() method.
     */
    public void run(){
        stop = false;
        current = 0;
	taskLength = -1;
	java.util.Vector r = new java.util.Vector();        
        runHelper(r);       
        results = new sandmark.diff.Result[r.size()];
        java.util.Collections.sort(r);
        for(int i = 0; i < r.size(); i++)
            results[i] = (sandmark.diff.Result)r.get(i);
    }      
 
    private void runHelper(java.util.Vector r){
	java.util.Vector methods1 = getMethods(app1);
	java.util.Vector methods2 = getMethods(app2);
	taskLength = methods1.size() * methods2.size();
	for(int i = 0; i < methods1.size(); i++){	   
            sandmark.program.Method m1 = (sandmark.program.Method)methods1.get(i);   
	    for (int j = 0; j < methods2.size(); j++){
		if(stop) 
                    return;
                current++;	
                sandmark.program.Method m2 = (sandmark.program.Method)methods2.get(j);
                //Do some preliminary checks based on options
                if(sandmark.diff.DiffUtil.check(m1, m2, options)){
                    sandmark.diff.Result result = diffMethods(m1,m2);
                     if(result != null)                 
                            r.add(result);
                }             
            }            
        }
    }
    /** @return a measure of the expected time to apply the algorithm. 
     *  See <code>getCurrent()</code>
     */
    public int getTaskLength(){ 
	return taskLength;
    }    
    /** Intended to be called while <code>run()</code> is being run in a separate thread.
     *  @return a measure of how much diffing the alorithm has completed.  
     */
    public int getCurrent(){
	return current;
    } 
    /** Stop this from running
     */
    public void stop(){
        stop = true;
    }
    /** @return an array of Result objects generated by this algorithm.
     */  
    public sandmark.diff.Result[] getResults(){
        return results;                
    }
    /** Diff two given method objects using this algorithm
     *  @param o1 the first method object
     *  @param o2 the second method object
     *  @return a Result object generated by this algorithm
     */
    public sandmark.diff.Result diff(sandmark.program.Object o1, 
                                     sandmark.program.Object o2){   
        return diffMethods((sandmark.program.Method)o1, 
                           (sandmark.program.Method)o2);               
    }
    /** All MethodDiffAlgorithms must implement this method
     *  @param m1 the first method
     *  @param m2 the second method
     *  @return a Result object generated by this algorithm
     */
    public abstract sandmark.diff.Result diffMethods(sandmark.program.Method m1, 
                                                     sandmark.program.Method m2);

    private java.util.Vector getMethods(sandmark.program.Application app){
	java.util.Vector v = new java.util.Vector();
	try{
	    java.util.Iterator classes = app.classes();
	    while(classes.hasNext()){	
                sandmark.program.Class cls = (sandmark.program.Class)classes.next();	
		String classname = cls.getName();
                sandmark.program.Method[] methods = cls.getMethods();
                sandmark.program.Field[] fields = cls.getFields();
		org.apache.bcel.generic.ConstantPoolGen cpg = cls.getConstantPool();
		for(int i = 0; i < methods.length; i++) {		  
                    sandmark.program.Method mg = methods[i];	
		    v.add(mg);	
		}
	    }
	}catch(Exception e){ System.out.println("Error loading class");  }
	return v;
    }
}
