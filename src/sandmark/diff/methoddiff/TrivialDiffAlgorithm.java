package sandmark.diff.methoddiff;

    /** Finds the longest common subsequence between all pairs of methods
     *	and returns similarity as a function of the length of the LCS.
     *  The algorithm can be applied by calling run()
     *  explicitly or creating a new thread: <code>new Thread(myAlgorithm).start()</code>.
     *  After applying the algorithm, call <code>getResults()</code>
     *  @author Zach Heidepriem
     */

public class TrivialDiffAlgorithm extends sandmark.diff.methoddiff.MethodDiffAlgorithm {   
    private static boolean DEBUG = false; //true;   
    private boolean DIFF_ARGS = false;
    
    /** Creates a TrivialDiffAlgorithm (diffs opcodes)
     *  @param a the first Application
     *  @param b the second Application
     *  @param o the set of DiffOptions to use when diffing
     */
    public TrivialDiffAlgorithm(sandmark.program.Application a,
       sandmark.program.Application b,
       sandmark.diff.DiffOptions o){
	super(a,b, o);
    }  
    /** Creates a TrvialDiffAlgorithm (literal diff)
     *  @param a the first Application
     *  @param b the second Application
     *  @param o the set of DiffOptions to use when diffing
     *  @param args If true, peform a literal comparison. If false,
     *  compare only opcodes. If not specified, default value is false;
     */
 
    public TrivialDiffAlgorithm(sandmark.program.Application a,
       sandmark.program.Application b,
				sandmark.diff.DiffOptions o,
				boolean args){
	super(a,b, o);
	if(args)
	    DIFF_ARGS = true;	
    }   
    /** @return the name of this algorithm
     */ 
    public String getName(){
	if(DIFF_ARGS)
	    return "Literal diff";
	else
	    return "Opcode diff";  
    }
    /** @return a short description of this algorithm
     */ 
    public String getDescription(){
	if(DIFF_ARGS)
	    return "Perform a literal comparison of methods";
	else
	    return "Perform a comparison of methods' opcodes, ignoring arguments";   
    }        
    /** Diff two given objects using this algorithm
     *  @param m1 the first method
     *  @param m2 the second method
     *  @return a Result object generated by this algorithm
     */
    public sandmark.diff.Result diffMethods(sandmark.program.Method m1, 
                                            sandmark.program.Method m2){
        if(m1.getInstructionList() == null || m2.getInstructionList() == null)
            return null;			    
        int[] array1; 
        int[] array2;
        if(DIFF_ARGS){
            array1 = sandmark.diff.DiffUtil.getOpsAndArgs(
                    m1.getInstructionList().getInstructionHandles());
            array2 = sandmark.diff.DiffUtil.getOpsAndArgs(
                    m2.getInstructionList().getInstructionHandles());
        }
        else{
            array1 = sandmark.diff.DiffUtil.getOps(
                   m1.getInstructionList().getInstructionHandles());
            array2 = sandmark.diff.DiffUtil.getOps(
                   m2.getInstructionList().getInstructionHandles());
        }				
        int lcs = sandmark.diff.LCS.getLength(array1, array2);		               
        double similarity = lcs / (double)Math.max(array1.length, array2.length);
        if(sandmark.diff.DiffUtil.sameNames(m1,m2) || similarity >= options.getFilter())         
            return new sandmark.diff.Result(m1,m2,similarity);        
        return null;
    }
    
    /** @param r The Result object to color
     *  @return The sandmark.diff.Coloring for r using this algorithm
     */
    public sandmark.diff.Coloring[] color(sandmark.diff.Result r){
	sandmark.diff.Coloring[] result = new sandmark.diff.Coloring[2];
        sandmark.program.Method m1 = (sandmark.program.Method)
            r.getObject1();
        sandmark.program.Method m2 = (sandmark.program.Method)
            r.getObject2();

	org.apache.bcel.generic.InstructionHandle[] il1 = 
            m1.getInstructionList().getInstructionHandles();
	org.apache.bcel.generic.InstructionHandle[] il2 = 
	    m2.getInstructionList().getInstructionHandles();

	int[] array1; 
	int[] array2;
	if(DIFF_ARGS){
	    array1 = sandmark.diff.DiffUtil.getOpsAndArgs(il1);
	    array2 = sandmark.diff.DiffUtil.getOpsAndArgs(il2);
	}
	else{
	    array1 = sandmark.diff.DiffUtil.getOps(il1);
	    array2 = sandmark.diff.DiffUtil.getOps(il2);
	}	
	java.util.Vector[] data = sandmark.diff.LCS.getSubsequence(array1, array2);   
	result[0] = new sandmark.diff.Coloring(il1.length, 
                                               m1.getClassName() + 
                                               "." +
                                               m1.getName());
	for(int i = 0; i < il1.length; i++){
	    if(data[0].contains(new Integer(i)))
		result[0].add(i, il1[i].toString(), 1);
	    else result[0].add(i, il1[i].toString());
	}
	result[1] = new sandmark.diff.Coloring(il2.length, 
                                               m2.getClassName() + 
                                               "." +
                                               m2.getName());
	for(int i = 0; i < il2.length; i++){
	    if(data[1].contains(new Integer(i)))
		result[1].add(i, il2[i].toString(), 1);
	    else result[1].add(i, il2[i].toString());
	}
	return result;
    }  
}

