package sandmark.diff.methoddiff;

/** A method diff algorithm that diffs structure of MethodCFG
 *  @author Zach Heidepriem
 */

public class CFGDiff extends sandmark.diff.methoddiff.MethodDiffAlgorithm {
    private boolean DEBUG = false;  
   
    /** Construct a CFGDiff
     *  @param a the first Application
     *  @param b the second Application
     *  @param o the set of DiffOptions to use when diffing
     */
    public CFGDiff(sandmark.program.Application a,
      sandmark.program.Application b,
      sandmark.diff.DiffOptions o){
	super(a,b, o);
    }
    /** @return the name of this algorithm
     */ 
    public String getName(){ return "Method CFG Diff"; }
    /** @return a short description of this algorithm
     */   
    public String getDescription(){ 
        return "Compare the structure of method CFG's"; 
    }      
 	    
    /** @param r The Result object to color
     *  @return The Coloring for r using this algorithm
     */
    public sandmark.diff.Coloring[] color(sandmark.diff.Result r){
	sandmark.diff.Coloring[] result = new sandmark.diff.Coloring[2];	
        sandmark.program.Method m1 = (sandmark.program.Method)
            r.getObject1();
        sandmark.program.Method m2 = (sandmark.program.Method)
            r.getObject2(); 
       	sandmark.diff.methoddiff.CFGTree t1 = ((CFGResult)r).getSubtree1();
       	sandmark.diff.methoddiff.CFGTree t2 = ((CFGResult)r).getSubtree2();

        org.apache.bcel.generic.Instruction[] il1 = 
	    m1.getInstructionList().getInstructions();
	org.apache.bcel.generic.Instruction[] il2 = 
	    m2.getInstructionList().getInstructions();

	sandmark.analysis.controlflowgraph.MethodCFG a = 
		    new sandmark.analysis.controlflowgraph.MethodCFG(m1);
	sandmark.analysis.controlflowgraph.MethodCFG b = 
		    new sandmark.analysis.controlflowgraph.MethodCFG(m2);
	java.util.Iterator it1 = a.basicBlockIterator();
       	java.util.Iterator it2 = b.basicBlockIterator();	

	result[0] = new sandmark.diff.Coloring(il1.length,
                                               m1.getClassName() + 
                                               "." +
                                               m1.getName());
        /*if(DEBUG){
          System.out.println(t1);
          System.out.println(t2);
        }*/
        int ctr = 1;
	while(it1.hasNext()){
            sandmark.analysis.controlflowgraph.BasicBlock block =
                (sandmark.analysis.controlflowgraph.BasicBlock)it1.next();
            int color = 0;
            if(t1.contains(block))
                color = ctr++;            
            for(int j = 0; j < block.getInstList().size(); j++)                
                result[0].add(block.getInstList().get(j).toString(), color);            
	}	
	result[1] = new sandmark.diff.Coloring(il2.length,
                                               m2.getClassName() + 
                                               "." +
                                               m2.getName());
        ctr = 1;
        while(it2.hasNext()){
            sandmark.analysis.controlflowgraph.BasicBlock block =
                (sandmark.analysis.controlflowgraph.BasicBlock)it2.next();
            int color = 0;
            if(t2.contains(block))
                color = ctr++;
	    for(int j = 0; j < block.getInstList().size(); j++)
		result[1].add(block.getInstList().get(j).toString(), color);            
	}
	return result;
    }    
 
    /** Diff two given objects using this algorithm
     *  @param m1 the first method
     *  @param m2 the second method
     *  @return a Result object generated by this algorithm
     */
    public sandmark.diff.Result diffMethods(sandmark.program.Method m1, 
                                            sandmark.program.Method m2){
        
        if(m1.getInstructionList() == null || m2.getInstructionList() == null){
            if(options.getFilter() == 0)
                return new sandmark.diff.Result(m1, m2, 0);
            else
                return null;
        }         
        
        sandmark.analysis.controlflowgraph.MethodCFG a = 
            new sandmark.analysis.controlflowgraph.MethodCFG(m1);
	sandmark.analysis.controlflowgraph.MethodCFG b = 
            new sandmark.analysis.controlflowgraph.MethodCFG(m2);       

        java.util.ArrayList backedges = a.getBackedges();
        for(int i = 0; i < backedges.size(); i+=2){
            a.removeEdge((sandmark.analysis.controlflowgraph.BasicBlock)backedges.get(i),
                         (sandmark.analysis.controlflowgraph.BasicBlock)backedges.get(i+1));
        }
        backedges = b.getBackedges();
        for(int i = 0; i < backedges.size(); i+=2){
            b.removeEdge((sandmark.analysis.controlflowgraph.BasicBlock)backedges.get(i),
                         (sandmark.analysis.controlflowgraph.BasicBlock)backedges.get(i+1));
        }          
       
        sandmark.diff.methoddiff.CFGTree t1 = 
            new sandmark.diff.methoddiff.CFGTree(a);
        sandmark.diff.methoddiff.CFGTree t2 = 
            new sandmark.diff.methoddiff.CFGTree(b);
        int max = Math.max(t1.nodeCount(), t2.nodeCount());
        //if(DEBUG) { a.printCFG(); b.printCFG(); }
        //if(DEBUG) System.out.println(t1.toString(true) +"\n" + t2.toString(true));
        
        double similarity = 0;              
        sandmark.diff.methoddiff.CFGTree maximumST1 = null, maximumST2 = null;
        java.util.Iterator it1 = t1.nodes();        
        while(it1.hasNext()){
            java.util.Iterator it2 = t2.nodes();           
            sandmark.diff.methoddiff.CFGTree subtree1 = t1.getSubtree(it1.next());
            while(it2.hasNext() && similarity < 1){
                sandmark.diff.methoddiff.CFGTree subtree2 = t2.getSubtree(it2.next());
                /*if(DEBUG && subtree1.nodeCount() == subtree2.nodeCount()){
                    System.out.println(subtree1);
                    System.out.println(subtree2);
                }*/
                double potentialSim = (double)subtree1.nodeCount() / 
                    (double)max;
                if(potentialSim >= options.getFilter() ||
                   sandmark.diff.DiffUtil.sameNames(m1,m2)){
                    if(potentialSim > similarity &&
                       sandmark.diff.methoddiff.CFGTree.isomorphic(subtree1, subtree2)){
                        maximumST1 = subtree1;
                        maximumST2 = subtree2;
                        similarity = potentialSim;
                        //System.out.println(similarity);
                    }
                }
            }
        }      
        if(sandmark.diff.DiffUtil.sameNames(m1,m2) || similarity >= options.getFilter())
            return new CFGResult(m1, m2, similarity, maximumST1, maximumST2);
        else 
            return null;
    }

    private class CFGResult extends sandmark.diff.Result {
        
        sandmark.diff.methoddiff.CFGTree subtree1, subtree2;

        public CFGResult(sandmark.program.Method m1,
                         sandmark.program.Method m2,
                         double similarity,
                         sandmark.diff.methoddiff.CFGTree subtree1,
                         sandmark.diff.methoddiff.CFGTree subtree2){

            super(m1,m2,similarity);
            this.subtree1 = subtree1;
            this.subtree2 = subtree2;
        }

        public sandmark.diff.methoddiff.CFGTree getSubtree1(){
            return subtree1;
        }

        public sandmark.diff.methoddiff.CFGTree getSubtree2(){
            return subtree2;
        }
    }
}

