package sandmark.analysis.slicingtools;

public class BackwardMethodSlice extends MethodSlice {

   boolean DEBUG = false;
   boolean DEBUG_KILL = false;
   
   

   public BackwardMethodSlice(sandmark.program.Method method,
      org.apache.bcel.generic.InstructionHandle startHandle,
      boolean staticSlice)
      throws RuntimeException {
         
      super(method, startHandle);

      if(staticSlice)
         computeStaticSlice();
      else
         computeDynamicSlice();
   }


   protected void computeStaticSlice(){
      for(int i=0; i < analysisBlockList.size(); i++){
         computeGen((AnalysisBlock)analysisBlockList.get(i));
         computeKill((AnalysisBlock)analysisBlockList.get(i));
      }

      computeReachingDefs();
      computeTransitiveClosure();
      identifyControlPredicates();
      setSlice();
      computeAffectedVars();
   }


   protected void computeDynamicSlice(){

      //needs to throw a not implemented exception
      throw new RuntimeException("Method not yet implemented");
   }



   /**
    * Computes the gen of a basic block. The gen is the set of definitions
    * generated by the block.
    */
   protected void computeGen(AnalysisBlock aBlock){

      java.util.ArrayList genList = new java.util.ArrayList();
      java.util.ArrayList etList = aBlock.getExprTrees();

      if(etList != null){
         for(int i=0; i < etList.size(); i++){
            sandmark.util.newexprtree.ExprTree exprTree =
               (sandmark.util.newexprtree.ExprTree)etList.get(i);
            java.util.ArrayList defList = exprTree.getDefs();
            
            if(defList.size() > 0)
               genList.add(exprTree);
         }//end for
      }//end if
      aBlock.setGen(genList);
   }

   /**
    * Computes the kill of a basic block. The kill is the set of definitions
    * killed by the block.
    */
   protected void computeKill(AnalysisBlock aBlock){
      java.util.ArrayList killList = new java.util.ArrayList();
      java.util.ArrayList etList = aBlock.getExprTrees();
      for(int i=0; i < etList.size(); i++){
         sandmark.util.newexprtree.ExprTree et = 
            (sandmark.util.newexprtree.ExprTree)etList.get(i);
         java.util.ArrayList defList1 = et.getDefs();
         for(int j=0; j < defList1.size(); j++){
            org.apache.bcel.generic.InstructionHandle defHandle1 =
               (org.apache.bcel.generic.InstructionHandle)defList1.get(j);
            org.apache.bcel.generic.Instruction defInst1 =
               defHandle1.getInstruction();
            org.apache.bcel.generic.LocalVariableInstruction defLVI1 =
               (org.apache.bcel.generic.LocalVariableInstruction)defInst1;
            int defLVIindex1 = defLVI1.getIndex();
            FOUND_DEF:
            for(int k=j; k < etList.size(); k++){
               sandmark.util.newexprtree.ExprTree exprTree2 =
                  (sandmark.util.newexprtree.ExprTree)etList.get(k);
               java.util.ArrayList defList2 = exprTree2.getDefs();
               for(int l=0; l < defList2.size(); l++){
                  org.apache.bcel.generic.InstructionHandle defHandle2 =
                     (org.apache.bcel.generic.InstructionHandle)defList2.get(l);
                  org.apache.bcel.generic.Instruction defInst2 =
                     defHandle2.getInstruction();
                  org.apache.bcel.generic.LocalVariableInstruction defLVI2 =
                     (org.apache.bcel.generic.LocalVariableInstruction)defInst2;
                  int defLVIindex2 = defLVI2.getIndex();
                  if(defLVIindex1 == defLVIindex2){
                     int defPos1 = defHandle1.getPosition();
                     int defPos2 = defHandle1.getPosition();
                     if(defPos1 >= defPos1){
                        killList.add(et);
                        if(DEBUG_KILL)System.out.println("added tree");
                        break FOUND_DEF;
                     }//end if
                  }//end if
               }//end for
            }//end for

         }//end for
      }//end for
      aBlock.setKill(killList);
   }//end computeKill

   protected void computeReachingDefs(){
      /* initialization step. For each block in the cfg set in to 0
         and out to gen.
      */
      for(int i=0; i < analysisBlockList.size(); i++){
         AnalysisBlock aBlock = (AnalysisBlock)analysisBlockList.get(i);
         aBlock.setOut(aBlock.getGen());
      }

      boolean change = true;
      while(change){
		   change = false;
         for(int j=0; j < analysisBlockList.size(); j++){
            AnalysisBlock block = (AnalysisBlock)analysisBlockList.get(j);
            java.util.ArrayList newin = new java.util.ArrayList();
	    java.util.Iterator predIter =
		met.preds(block.getBB());
	    while (predIter.hasNext()) {
	       sandmark.analysis.controlflowgraph.BasicBlock bb = 
		  (sandmark.analysis.controlflowgraph.BasicBlock)predIter.next();
               sandmark.util.newexprtree.ExprTreeBlock etb = 
                  met.getExprTreeBlock(bb);
               AnalysisBlock p = (AnalysisBlock)analysisBlockMap.get(etb);
               if(p != null)newin = computeUnion(newin, p.getOut());
            }//end for
            if(compare(block.getIn(), newin) != 0){
               change = true;
               block.setIn(newin);
               java.util.ArrayList differenceList =
                  computeDifference(block.getIn(), block.getKill());
               java.util.ArrayList unionList = 
                  computeUnion(differenceList, block.getGen());
               block.setOut(unionList);
            }
         }//end for
      }//end while
   }//end computeReachingDefs


   protected void computeTransitiveClosure(){
      java.util.ArrayList checkList = new java.util.ArrayList();
      java.util.ArrayList localVarIndexList = new java.util.ArrayList();
      AnalysisBlock aStartBlock = (AnalysisBlock)analysisBlockMap.get(startBlock);

      checkList.add(aStartBlock);
      Integer localVarIndex = new Integer(lvIndex);
      localVarIndexList.add(localVarIndex);

      boolean change = true;

      while(change){
         if(DEBUG)System.out.println("in trans closure loop");
         change = false;
         java.util.ArrayList newCheckList = new java.util.ArrayList();
         if(DEBUG)System.out.println("checkList size: " + checkList.size());
         for(int i=0; i < checkList.size(); i++){
            AnalysisBlock ablock = (AnalysisBlock)checkList.get(i);
            java.util.ArrayList in = new java.util.ArrayList();
            if(DEBUG)System.out.println("aBlock: " + ablock);
            if(ablock == null)
               break;
            else
               in = ablock.getOut(); //ablock.getIn();
            for(int j=0; j < in.size(); j++){
               sandmark.util.newexprtree.ExprTree et =
                  (sandmark.util.newexprtree.ExprTree)in.get(j);
               java.util.ArrayList defs = et.getDefs();
               if(DEBUG)System.out.println("defs: " + defs);
               for(int k=0; k < defs.size(); k++){
                  org.apache.bcel.generic.InstructionHandle defHandle =
                     (org.apache.bcel.generic.InstructionHandle)defs.get(k);
                  org.apache.bcel.generic.Instruction defInst =
                     defHandle.getInstruction();
                  if(defInst instanceof
                     org.apache.bcel.generic.LocalVariableInstruction){
                     org.apache.bcel.generic.LocalVariableInstruction lvInst =
                        (org.apache.bcel.generic.LocalVariableInstruction)defInst;
                     int index = lvInst.getIndex();
                     localVarIndex = new Integer(index);
                     if(localVarIndexList.contains(localVarIndex)){
                        sliceTrees.add(et);
                        if(DEBUG)System.out.println("added exprTree to slice: " + et);
                        java.util.ArrayList uses = et.getUses();
                        for(int l=0; l < uses.size(); l++){
                           org.apache.bcel.generic.InstructionHandle useHandle =
                              (org.apache.bcel.generic.InstructionHandle)uses.get(l);
                           org.apache.bcel.generic.Instruction useInst =
                              useHandle.getInstruction();
                           if(useInst instanceof
                              org.apache.bcel.generic.LocalVariableInstruction){
                              org.apache.bcel.generic.LocalVariableInstruction
                                 lvI = 
                                 (org.apache.bcel.generic.LocalVariableInstruction)
                                 useInst;
                              index = lvI.getIndex();
                              localVarIndex = new Integer(index);
                              localVarIndexList.add(localVarIndex);
                           }//end if
                        }//end for
                        sandmark.util.newexprtree.ExprTreeBlock etb =
                           et.getExprTreeBlock();
                        AnalysisBlock ab = 
                           (AnalysisBlock)analysisBlockMap.get(etb);
                        if(ab != null)newCheckList.add(ab);
                        change = true;
                     }//end if
                  }//end if
               }//end for
            }//end for
         }//end for
         checkList = newCheckList;
      }//end while
   }


   private void identifyControlPredicates(){
      
      for(int i=0; i < metBlockList.size(); i++){
         sandmark.util.newexprtree.ExprTreeBlock etb =
            (sandmark.util.newexprtree.ExprTreeBlock)metBlockList.get(i);
         java.util.ArrayList etList = etb.getExprTrees();
         for(int j=0; j < etList.size(); j++){
            sandmark.util.newexprtree.ExprTree et =
               (sandmark.util.newexprtree.ExprTree)etList.get(j);
            java.util.ArrayList etInstList = et.getInstructionList();
            FOUND_BRANCH:
            for(int k=0; k < etInstList.size(); k++){
               org.apache.bcel.generic.InstructionHandle ih =
                  (org.apache.bcel.generic.InstructionHandle)etInstList.get(k);
               org.apache.bcel.generic.Instruction inst = ih.getInstruction();
               if(inst instanceof org.apache.bcel.generic.BranchInstruction){
                  java.util.ArrayList uses = et.getUses();
                  for(int l=0; l < uses.size(); l++){
                     org.apache.bcel.generic.InstructionHandle useHandle =
                        (org.apache.bcel.generic.InstructionHandle)uses.get(l);
                     org.apache.bcel.generic.Instruction useInst =
                        useHandle.getInstruction();
                     if(useInst instanceof
                        org.apache.bcel.generic.LocalVariableInstruction){
                        org.apache.bcel.generic.LocalVariableInstruction useLVI
                           = (org.apache.bcel.generic.LocalVariableInstruction)useInst;
                        int useIndex = useLVI.getIndex();
                        if(useIndex == lvIndex){
                           if(!sliceTrees.contains(et)){
                              sliceTrees.add(et);
                              if(DEBUG)System.out.println("added because of branch");
                              break FOUND_BRANCH;
                           }//end if
                        }//end if
                     }//end if
                  }//end for
               }//end if
            }// for
         }//end for
      }//end for
   }

}//end BackwardMethodSlice
